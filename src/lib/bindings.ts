// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/

export const commands = {
	async isDbInitialized(): Promise<boolean> {
		return await TAURI_INVOKE('is_db_initialized');
	},
	/**
	 * Tauri command to retrieve the current collection.
	 *
	 * This handler constructs the repository and use-case, executes the use-case
	 * asynchronously and returns the `Collection` on success. On failure it
	 * converts the error into a `CommandError::Unknown` preserving the error
	 * message for logging/debugging.
	 *
	 * Parameters:
	 * - `state`: Tauri-managed application state which provides a database pool.
	 *
	 * Returns:
	 * - `Ok(Collection)` when retrieval succeeds.
	 * - `Err(CommandError)` when the use-case returns an error.
	 */
	async getCollection(): Promise<Result<Collection, CommandError>> {
		try {
			return { status: 'ok', data: await TAURI_INVOKE('get_collection') };
		} catch (e) {
			if (e instanceof Error) throw e;
			else return { status: 'error', error: e as any };
		}
	},
	async getAppVersion(): Promise<string> {
		return await TAURI_INVOKE('get_app_version');
	}
};

/** user-defined events **/

/** user-defined constants **/

/** user-defined types **/

/**
 * Represents a user-owned collection of items.
 *
 * A `Collection` contains identifying information, a few aggregated summary
 * values and the list of `CollectionItem` entries that make up the
 * collection. It is intentionally lightweight to keep IPC payloads small.
 */
export type Collection = {
	/**
	 * Unique identifier for the collection (typically a UUID stored as a string).
	 */
	id: string;
	/**
	 * Display name for this collection.
	 */
	name: string;
	/**
	 * Precomputed summary counts (e.g. total items, tracked vs untracked).
	 */
	summary: CollectionSummary;
	/**
	 * Optional total monetary value of the collection. Use `MonetaryAmount`
	 * to preserve currency and decimal precision.
	 */
	total_value: MonetaryAmount | null;
	/**
	 * The list of items contained in this collection.
	 */
	items: CollectionItem[];
};
/**
 * A single item within a user's collection.
 *
 * A `CollectionItem` represents a reference to a catalog `RailwayModel` along
 * with ownership-specific data such as the rolling stock instances owned by
 * the collector and purchase information. It is intentionally a lightweight
 * entity that is meaningful only inside the context of its parent
 * `Collection` (the aggregate root).
 */
export type CollectionItem = {
	/**
	 * Unique identifier for this collection item (e.g. UUID).
	 */
	id: string;
	/**
	 * Link to the corresponding catalog `RailwayModel` this item represents.
	 *
	 * This is a reference to the canonical model in the catalog; use this
	 * to look up full catalog details (manufacturer, product codes, etc.).
	 */
	railway_model_id: string;
	/**
	 * Manufacturer name of the model (copied or stored for quick access).
	 */
	manufacturer: string;
	/**
	 * Manufacturer product code for the model (kept as a value object).
	 */
	product_code: ProductCode;
	/**
	 * Human-readable description of this item or model.
	 */
	description: string;
	/**
	 * The power method for the model (e.g. AC, DC, None).
	 */
	power_method: PowerMethod;
	/**
	 * The scale of the model (e.g. H0, N).
	 */
	scale: Scale;
	/**
	 * The historical epoch associated with the model.
	 */
	epoch: Epoch;
	/**
	 * The specific rolling stock instances owned that correspond to this model.
	 */
	rolling_stocks: OwnedRollingStock[];
	/**
	 * Optional purchase information associated with this collection item.
	 */
	purchase_info: PurchaseInfo | null;
};
/**
 * Summary counters for a `Collection` domain object.
 */
export type CollectionSummary = {
	/**
	 * Number of locomotives in the collection.
	 */
	locomotives_count: number;
	/**
	 * Number of passenger cars in the collection.
	 */
	passenger_cars_count: number;
	/**
	 * Number of freight cars in the collection.
	 */
	freight_cars_count: number;
	/**
	 * Number of train sets in the collection.
	 */
	train_sets_count: number;
	/**
	 * Number of railcars in the collection.
	 */
	railcars_count: number;
	/**
	 * Number of electric multiple units (EMUs) in the collection.
	 */
	electric_multiple_units_count: number;
};
/**
 * Application-level error returned by command handlers in the core infrastructure.
 *
 * Variants are simple wrappers around strings to keep boundaries between
 * infrastructure and domain code straightforward. Prefer constructing
 * `CommandError::DatabaseError` when an underlying DB call fails, and
 * `CommandError::Unknown` for unexpected failures.
 */
export type CommandError =
	/**
	 * Represents an error coming from the database layer.
	 *
	 * The inner `String` should contain a concise, non-sensitive description
	 * of the underlying database failure.
	 */
	| { DatabaseError: string }
	/**
	 * A catch-all for unexpected errors that don't map to a specific variant.
	 *
	 * The inner `String` can include a short debug message suitable for
	 * logging; avoid placing secrets here.
	 */
	| { Unknown: string };
/**
 * Currency codes supported by the application.
 *
 * The enum uses a small, explicit set of currencies for now. Use
 * `Currency::from_code` to obtain a `Currency` value from an ISO-style
 * currency code (case-insensitive).
 */
export type Currency =
	/**
	 * Euro
	 */
	| 'EUR'
	/**
	 * United States Dollar
	 */
	| 'USD'
	/**
	 * Great Britain Pound
	 */
	| 'GBP'
	/**
	 * Japanese Yen
	 */
	| 'JPY';
/**
 * Backwards-compatible wrapper used across the codebase and DB rows.
 *
 * This preserves the original `Epoch(pub String)` API while providing
 * conversions to the structured `EpochKind` for validation and richer handling.
 */
export type Epoch = string;
/**
 * A monetary amount in the smallest currency unit together with its currency.
 *
 * `MonetaryAmount` stores the raw integer amount (e.g. cents) in `amount` and
 * the `currency` that the amount is denominated in. Prefer using the provided
 * constructors rather than populating fields directly.
 *
 * # Examples
 *
 * Basic construction and display:
 *
 * ```rust
 * # use rusty_shed_lib::core::domain::{Currency, MonetaryAmount};
 * let m = MonetaryAmount::new(1050, Currency::EUR);
 * assert_eq!(m.to_string(), "10.50 â‚¬");
 * ```
 *
 * Constructing from DB parts (nullable currency):
 *
 * ```rust
 * # use rusty_shed_lib::core::domain::{Currency, MonetaryAmount};
 * let m = MonetaryAmount::from_db(1234, Some("USD")).unwrap();
 * assert_eq!(m.unwrap().currency, Currency::USD);
 * let none = MonetaryAmount::from_db(0, None).unwrap();
 * assert!(none.is_none());
 * ```
 */
export type MonetaryAmount = {
	/**
	 * Amount stored in the smallest unit (e.g. cents for EUR/USD/GBP).
	 */
	amount: bigint;
	/**
	 * Currency of the amount.
	 */
	currency: Currency;
};
/**
 * A lightweight view of rolling stock that references catalog model data.
 *
 * This struct intentionally contains only the minimal information needed by
 * the collecting domain to reference a catalog `RailwayModel` and basic
 * provenance (railway and epoch). Detailed model information lives in the
 * catalog domain and should not be duplicated here.
 */
export type OwnedRollingStock = {
	/**
	 * Unique identifier for this owned rolling stock record (e.g. UUID in the DB).
	 */
	id: string;
	/**
	 * Identifier of the related rolling stock in the catalog (or the owned rolling stock id when catalog id is not available).
	 */
	rolling_stock_id: string;
	/**
	 * Free-form notes associated with this owned instance.
	 * Use this for short owner notes or a brief textual label.
	 */
	notes: string;
	/**
	 * Identifier for the railway company.
	 */
	railway_id: string;
	/**
	 * Historical epoch for this owned vehicle (copied from the catalog model).
	 */
	epoch: Epoch;
};
/**
 * Power method used by rolling stocks.
 *
 * This enum represents how a model locomotive obtains electrical power.
 * The `Display` implementation returns a human-friendly name for each variant.
 */
export type PowerMethod =
	/**
	 * Alternating current (AC) power collection.
	 */
	| 'AC'
	/**
	 * Direct current (DC) power collection.
	 */
	| 'DC'
	/**
	 * Trix Express three-rail power pickup system.
	 */
	| 'TRIX_EXPRESS';
/**
 * A product identifier (manufacturer model/code) used to uniquely identify
 * a rolling stock model or catalogue item.
 *
 * This is a thin newtype wrapper around `String` to provide domain-level
 * type-safety and to allow attaching trait impls specific to product codes.
 *
 * It derives `Serialize`/`Deserialize` for easy (de)serialization with Serde.
 */
export type ProductCode = string;
/**
 * Purchase information associated with a `CollectionItem`.
 *
 * This structure stores details about the acquisition of a collection item,
 * including an identifier, purchase date, price and seller.
 */
export type PurchaseInfo = {
	/**
	 * Unique identifier for the purchase record (e.g. UUID).
	 */
	id: string;
	/**
	 * The collection item this purchase info refers to.
	 */
	item_id: string;
	/**
	 * The purchase date (stored as a `NaiveDate`).
	 *
	 * Parsed from the database string (ISO 8601 `YYYY-MM-DD` expected).
	 */
	purchase_date: string;
	/**
	 * Price represented as an optional `MonetaryAmount`. `None` means the currency
	 * was not present in the DB (NULL) or price is unknown.
	 */
	price: MonetaryAmount | null;
	/**
	 * Seller name or vendor identifier.
	 */
	seller: string;
};
/**
 * Represents the model railway scale used by rolling stock.
 *
 * Each `Scale` variant has a numeric ratio associated with it (the value after
 * `1:`). Use `Scale::ratio()` to retrieve the numeric value (e.g. `87.0` for H0).
 * The `Display` implementation formats the scale including the ratio, for
 * example: `H0 (1:87)` or `G (1:22.5)`.
 */
export type Scale = 'H0' | 'H0m' | 'H0e' | 'N' | 'TT' | 'Z' | 'G' | 'Scale1' | 'Scale0';

/** tauri-specta globals **/

import { invoke as TAURI_INVOKE, Channel as TAURI_CHANNEL } from '@tauri-apps/api/core';
import * as TAURI_API_EVENT from '@tauri-apps/api/event';
import { type WebviewWindow as __WebviewWindow__ } from '@tauri-apps/api/webviewWindow';

type __EventObj__<T> = {
	listen: (cb: TAURI_API_EVENT.EventCallback<T>) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (cb: TAURI_API_EVENT.EventCallback<T>) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> = { status: 'ok'; data: T } | { status: 'error'; error: E };

function __makeEvents__<T extends Record<string, any>>(mappings: Record<keyof T, string>) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg)
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case 'listen':
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case 'once':
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case 'emit':
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					}
				});
			}
		}
	);
}
