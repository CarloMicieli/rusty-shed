
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async isDbInitialized() : Promise<boolean> {
    return await TAURI_INVOKE("is_db_initialized");
},
/**
 * Tauri command to retrieve the current collection.
 * 
 * This handler constructs the repository and use-case, executes the use-case
 * asynchronously and returns the `Collection` on success. On failure it
 * converts the error into a `CommandError::Unknown` preserving the error
 * message for logging/debugging.
 * 
 * Parameters:
 * - `state`: Tauri-managed application state which provides a database pool.
 * 
 * Returns:
 * - `Ok(Collection)` when retrieval succeeds.
 * - `Err(CommandError)` when the use-case returns an error.
 */
async getCollection() : Promise<Result<Collection, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_collection") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAppVersion() : Promise<string> {
    return await TAURI_INVOKE("get_app_version");
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

/**
 * Represents a user-owned collection of items.
 * 
 * A `Collection` contains identifying information, a few aggregated summary
 * values and the list of `CollectionItem` entries that make up the
 * collection. It is intentionally lightweight to keep IPC payloads small.
 */
export type Collection = { 
/**
 * Unique identifier for the collection (typically a UUID stored as a string).
 */
id: string; 
/**
 * Display name for this collection.
 */
name: string; 
/**
 * Precomputed summary counts (e.g. total items, tracked vs untracked).
 */
summary: CollectionSummary; 
/**
 * Optional total monetary value of the collection. Use `MonetaryAmount`
 * to preserve currency and decimal precision.
 */
total_value: MonetaryAmount | null; 
/**
 * The list of items contained in this collection.
 */
items: CollectionItem[] }
/**
 * A single item within a user's collection.
 * 
 * A `CollectionItem` represents a reference to a catalog `RailwayModel` along
 * with ownership-specific data such as the rolling stock instances owned by
 * the collector and purchase information. It is intentionally a lightweight
 * entity that is meaningful only inside the context of its parent
 * `Collection` (the aggregate root).
 */
export type CollectionItem = { 
/**
 * Unique identifier for this collection item (e.g. UUID).
 */
id: string; 
/**
 * Link to the corresponding catalog `RailwayModel` this item represents.
 * 
 * This is a reference to the canonical model in the catalog; use this
 * to look up full catalog details (manufacturer, product codes, etc.).
 */
railway_model_id: string; 
/**
 * Condition of the item as recorded by the owner (e.g. "mint", "used").
 */
conditions: string | null; 
/**
 * Free-form notes provided by the owner for this collection item.
 */
notes: string | null; 
/**
 * The specific rolling stock instances owned that correspond to this model.
 */
rolling_stocks: OwnedRollingStock[]; 
/**
 * Optional purchase information associated with this collection item.
 */
purchase_info: PurchaseInfo | null }
/**
 * Summary counters for a `Collection` domain object.
 */
export type CollectionSummary = { 
/**
 * Number of locomotives in the collection.
 */
locomotives_count: number; 
/**
 * Number of passenger cars in the collection.
 */
passenger_cars_count: number; 
/**
 * Number of freight cars in the collection.
 */
freight_cars_count: number; 
/**
 * Number of train sets in the collection.
 */
train_sets_count: number; 
/**
 * Number of railcars in the collection.
 */
railcars_count: number; 
/**
 * Number of electric multiple units (EMUs) in the collection.
 */
electric_multiple_units_count: number }
/**
 * Application-level error returned by command handlers in the core infrastructure.
 * 
 * Variants are simple wrappers around strings to keep boundaries between
 * infrastructure and domain code straightforward. Prefer constructing
 * `CommandError::DatabaseError` when an underlying DB call fails, and
 * `CommandError::Unknown` for unexpected failures.
 */
export type CommandError = 
/**
 * Represents an error coming from the database layer.
 * 
 * The inner `String` should contain a concise, non-sensitive description
 * of the underlying database failure.
 */
{ DatabaseError: string } | 
/**
 * A catch-all for unexpected errors that don't map to a specific variant.
 * 
 * The inner `String` can include a short debug message suitable for
 * logging; avoid placing secrets here.
 */
{ Unknown: string }
/**
 * Currency codes supported by the application.
 * 
 * The enum uses a small, explicit set of currencies for now. Use
 * `Currency::from_code` to obtain a `Currency` value from an ISO-style
 * currency code (case-insensitive).
 */
export type Currency = 
/**
 * Euro
 */
"EUR" | 
/**
 * United States Dollar
 */
"USD" | 
/**
 * Great Britain Pound
 */
"GBP" | 
/**
 * Japanese Yen
 */
"JPY"
/**
 * A monetary amount in the smallest currency unit together with its currency.
 * 
 * `MonetaryAmount` stores the raw integer amount (e.g. cents) in `amount` and
 * the `currency` that the amount is denominated in. Prefer using the provided
 * constructors rather than populating fields directly.
 * 
 * # Examples
 * 
 * Basic construction and display:
 * 
 * ```rust
 * # use rusty_shed_lib::core::domain::{Currency, MonetaryAmount};
 * let m = MonetaryAmount::new(1050, Currency::EUR);
 * assert_eq!(m.to_string(), "10.50 â‚¬");
 * ```
 * 
 * Constructing from DB parts (nullable currency):
 * 
 * ```rust
 * # use rusty_shed_lib::core::domain::{Currency, MonetaryAmount};
 * let m = MonetaryAmount::from_db(1234, Some("USD")).unwrap();
 * assert_eq!(m.unwrap().currency, Currency::USD);
 * let none = MonetaryAmount::from_db(0, None).unwrap();
 * assert!(none.is_none());
 * ```
 */
export type MonetaryAmount = { 
/**
 * Amount stored in the smallest unit (e.g. cents for EUR/USD/GBP).
 */
amount: bigint; 
/**
 * Currency of the amount.
 */
currency: Currency }
/**
 * A lightweight view of rolling stock that references catalog model data.
 * 
 * This struct intentionally contains only the minimal information needed by
 * the collecting domain to reference a catalog `RollingStock` and basic
 * provenance. Detailed model information lives in the catalog domain and
 * should not be duplicated here. Fields like railway and epoch are no longer
 * stored on the owned_rolling_stocks table and should be obtained from the
 * catalog when needed.
 */
export type OwnedRollingStock = { 
/**
 * Unique identifier for this owned rolling stock record (e.g. UUID in the DB).
 */
id: string; 
/**
 * Identifier of the related rolling stock in the catalog (or the owned rolling stock id when catalog id is not available).
 */
rolling_stock_id: string; 
/**
 * Free-form notes associated with this owned instance.
 * Use this for short owner notes or a brief textual label.
 */
notes: string }
/**
 * Details for a pre-order entry.
 * 
 * Preorders record at least the deposit paid and the total price expected
 * for the item. Both monetary amounts must use the same currency; use the
 * `validate_currencies_match` helper to assert that condition.
 */
export type PreOrderInfo = { 
/**
 * Unique identifier for this preorder record.
 */
id: string; 
/**
 * Date when the preorder was placed (ISO `YYYY-MM-DD`).
 */
order_date: string; 
/**
 * Amount paid as deposit (in smallest unit + currency).
 */
deposit: MonetaryAmount; 
/**
 * Total price for the pre-ordered item (in smallest unit + currency).
 */
total_price: MonetaryAmount; 
/**
 * Optional seller identifier or shop name.
 */
seller: string | null; 
/**
 * Optional expected delivery date (ETA) for the preorder.
 */
expected_date: string | null }
/**
 * Purchase information associated with a `CollectionItem`.
 * 
 * A collection item may have acquisition-related metadata that describes how
 * the user obtained (or intends to obtain) the item. This enum models the
 * three supported acquisition states:
 * 
 * - `Purchased`: the item was purchased and its value is counted in the
 * collection total (unless explicitly excluded elsewhere).
 * - `Sold`: the item was sold; we keep a record of the original purchase
 * and the sale, but the item is excluded from the collection's monetary
 * total value.
 * - `PreOrdered`: the item is pre-ordered from a seller; the collector may
 * have paid a deposit and the full total price is known as well.
 */
export type PurchaseInfo = 
/**
 * A standard purchase record.
 */
{ kind: "purchased"; data: PurchasedInfo } | 
/**
 * A sold item record that preserves original purchase data and the
 * subsequent sale information.
 */
{ kind: "sold"; data: SoldInfo } | 
/**
 * A preorder record with deposit and total price information.
 */
{ kind: "preordered"; data: PreOrderInfo }
/**
 * Details for a purchased item.
 * 
 * This struct holds the canonical purchase identifier and optional price
 * information. `price` is optional to support legacy records where the
 * monetary amount or currency was not stored.
 */
export type PurchasedInfo = { 
/**
 * Unique identifier for this purchase record (for example a UUID).
 */
id: string; 
/**
 * Date when the item was purchased (ISO `YYYY-MM-DD`).
 */
purchase_date: string; 
/**
 * The price paid when purchasing the item, if known.
 * 
 * Represented as a domain `MonetaryAmount` (amount in smallest unit + currency).
 */
price: MonetaryAmount | null; 
/**
 * Optional seller identifier or human-friendly name.
 */
seller: string | null }
/**
 * Details for an item that was sold.
 * 
 * We keep both the original purchase information and the sale data so the
 * application can show provenance (what was paid originally) together with
 * the sale outcome. The item should be excluded from collection value
 * aggregations once sold.
 */
export type SoldInfo = { 
/**
 * Unique identifier for the original purchase record (or the sale record,
 * depending on how you model identifiers). This is the canonical id for
 * the persisted purchase_info row.
 */
id: string; 
/**
 * Date when the item was originally purchased (ISO `YYYY-MM-DD`).
 */
purchase_date: string; 
/**
 * Original purchase price, if available.
 * 
 * Use `None` to indicate the original price is unknown or not stored.
 */
purchase_price: MonetaryAmount | null; 
/**
 * Date when the item was sold (ISO `YYYY-MM-DD`).
 */
sale_date: string; 
/**
 * Price obtained when the item was sold. This value is required for
 * `Sold` records because a sale without a price is not meaningful for
 * financial reporting.
 */
sale_price: MonetaryAmount; 
/**
 * Optional buyer identifier (when the buyer is a tracked entity).
 */
buyer: string | null; 
/**
 * Optional seller identifier for completeness (may be the shop that
 * originally sold the item or the intermediary that handled the sale).
 */
seller: string | null }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
